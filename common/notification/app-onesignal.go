package notification

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/cobinhood/cobinhood-backend/types"
)

const (
	// OnesignalSymbol defines the app service type that should be defined
	// in config.
	OnesignalSymbol = "Onesignal"
)

var (
	oneSignalRestURL = "https://onesignal.com/api/v1/notifications"
)

// OneSignalConfig defines config of onesignal.
type OneSignalConfig struct {
	APIKey string `config:"OnesignalRestApiKey"`
	AppID  string `config:"OnesignalAppId"`
}

func onesignalContentsCheck(subject, message map[types.OneSignalLanguage]string) bool {
	if _, ok := subject[types.English]; !ok {
		return false
	}
	if _, ok := message[types.English]; !ok {
		return false
	}
	for k := range subject {
		if !k.IsValid() {
			return false
		}
		if _, ok := message[k]; !ok {
			return false
		}
	}
	return len(subject) == len(message)
}

// Send sends notification via Onesignal in filter mode to specify the
// devices with specified tag name which is generated by GetNotificationTag.
func (o *OneSignalConfig) Send(ctx context.Context,
	appReq *AppRequest) (err error) {
	if !onesignalContentsCheck(appReq.Subject, appReq.Message) {
		return errors.New("onesignalContentsCheck failed")
	}
	data := map[string]interface{}{
		"app_id":   o.AppID,
		"headings": appReq.Subject,
		"contents": appReq.Message,
		"filters": []map[string]string{
			{
				"field":    "tag",
				"key":      "notification_tag",
				"relation": "=",
				"value":    appReq.ID,
			},
		},
		"data": appReq.ReturnData,
	}

	client := &http.Client{}
	jsonStr, err := json.Marshal(data)
	if err != nil {
		return
	}
	req, err := http.NewRequest(
		http.MethodPost, oneSignalRestURL, bytes.NewBuffer(jsonStr))
	if err != nil {
		return
	}
	req.Header.Add("Authorization", "Basic "+o.APIKey)
	req.Header.Add("Content-Type", "application/json; charset=utf-8")

	req = req.WithContext(ctx)
	rsp, err := client.Do(req)

	if err != nil {
		return
	}

	var rspJSON = struct {
		ID     string   `json:"id"`
		Errors []string `json:"errors"`
	}{}
	rspBody, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return
	}

	json.Unmarshal(rspBody, &rspJSON)
	if len(rspJSON.Errors) > 0 {
		str := strings.Join(rspJSON.Errors, " ")
		err = fmt.Errorf(
			`error in onesignal response (data: %+v, message: %s,
			 user_id = %v)`,
			data,
			str,
			appReq.UserID,
		)
	}
	return
}

type viewNotificationResp struct {
	ID                    string                 `json:"id"`
	Successful            int                    `json:"successful"`
	Failed                int                    `json:"failed"`
	Converted             int                    `json:"converted"`
	Remaining             int                    `json:"remaining"`
	QueuedAt              int64                  `json:"queued_at"`
	SendAfter             int64                  `json:"send_after"`
	CompletedAt           int64                  `json:"completed_at"`
	URL                   string                 `json:"url"`
	Data                  map[string]string      `json:"data"`
	Canceled              bool                   `json:"canceled"`
	Headings              map[string]string      `json:"headings"`
	Contents              map[string]string      `json:"contents"`
	PlatformDeliveryStats map[string]interface{} `json:"platform_delivery_stats"`
}

func (o *OneSignalConfig) viewNotificationOnesignal(
	ctx context.Context, notificationID string) {

	client := &http.Client{}
	req, err := http.NewRequest(
		http.MethodGet, oneSignalRestURL+"/"+notificationID, nil)
	if err != nil {
		return
	}
	req.Header.Add("Authorization", "Basic "+o.APIKey)

	q := req.URL.Query()
	q.Add("app_id", o.AppID)
	req.URL.RawQuery = q.Encode()

	req = req.WithContext(ctx)
	rsp, err := client.Do(req)

	if err != nil {
		return
	}

	var rspJSON viewNotificationResp
	rspBody, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return
	}
	json.Unmarshal(rspBody, &rspJSON)
}

// BatchSend sends notification via Onesignal in filter mode to specify the
// devices with specified tag name which is generated by GetNotificationTag.
func (o *OneSignalConfig) BatchSend(ctx context.Context,
	appReq *BatchAppRequest) (notificationID string, recipients int, err error) {
	data := map[string]interface{}{
		"app_id":   o.AppID,
		"headings": appReq.Subjects,
		"contents": appReq.Contents,
		"filters":  appReq.Filters,
		"data":     appReq.ReturnData,
		"url":      appReq.URL,
	}

	for _, device := range appReq.Options {
		switch device {
		case types.DeviceIOS:
			data["isIos"] = true
		case types.DeviceAndroid:
			data["isAndroid"] = true
		case types.DeviceWeb:
			data["isAnyWeb"] = true
		}
	}

	if appReq.Schedule != nil {
		if appReq.Schedule.IsOptimized {
			data["delayed_option"] = "timezone"
			data["delivery_time_of_day"] =
				appReq.Schedule.SendAfter.Add(time.Minute * 5).Format("3:04PM")
		}
		t := appReq.Schedule.SendAfter
		data["send_after"] = t.Format("2006-01-02 15:04:05 GMT-0700")
	}

	client := &http.Client{}
	jsonStr, err := json.Marshal(data)
	if err != nil {
		return
	}
	req, err := http.NewRequest(
		http.MethodPost, oneSignalRestURL, bytes.NewBuffer(jsonStr))
	if err != nil {
		return
	}
	req.Header.Add("Authorization", "Basic "+o.APIKey)
	req.Header.Add("Content-Type", "application/json; charset=utf-8")

	req = req.WithContext(ctx)
	rsp, err := client.Do(req)

	if err != nil {
		return
	}

	var rspJSON = struct {
		ID         string   `json:"id"`
		Recipients int      `json:"recipients"`
		Errors     []string `json:"errors"`
	}{}
	rspBody, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return
	}

	err = json.Unmarshal(rspBody, &rspJSON)
	if err != nil {
		return
	}
	if len(rspJSON.Errors) > 0 {
		str := strings.Join(rspJSON.Errors, " ")
		err = fmt.Errorf(`error in onesignal response (data: %+v, message: %s)`,
			data,
			str,
		)
	}

	notificationID = rspJSON.ID
	recipients = rspJSON.Recipients
	return
}
